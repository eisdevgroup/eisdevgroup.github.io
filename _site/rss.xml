<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>EIS Development Team Blog</title>
        <description>EIS Development Team Blog - EIS devteam</description>
        <link></link>
        <link></link>
        <lastBuildDate>2014-06-17T16:51:21+04:00</lastBuildDate>
        <pubDate>2014-06-17T16:51:21+04:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>Play with P-JAX</title>
                <description>
&lt;h2 id=&quot;p-jax&quot;&gt;P-JAX&lt;/h2&gt;

&lt;h3 id=&quot;p-jax-1&quot;&gt;Что такое P-JAX.&lt;/h3&gt;

&lt;p&gt;P-JAX представляет собой плагин для jQuery, позволяющий перезагружать участок web-страницы и при этом изменять состояние адресной строки браузера и историю посещения страниц.
Проект открытый, исходный код доступен &lt;a href=&quot;https://github.com/defunkt/jquery-pjax&quot;&gt;на GitHub&lt;/a&gt;. Также доступно приложение, чтобы потестировать плагин, &lt;a href=&quot;http://pjax.heroku.com&quot;&gt;на Heroku&lt;/a&gt;.
P-JAX используется самим GitHub.&lt;/p&gt;

&lt;h3 id=&quot;p-jax-2&quot;&gt;Как работает P-JAX&lt;/h3&gt;

&lt;p&gt;Название представляет собой объединенные 2 термина: PushState и AJAX.
Магия технологии заключается в следующем:
* При нажатии на ссылку, для которой включен P-JAX, отпраляется AJAX запрос на сервер с указанием заголовка &lt;em&gt;X-PJAX: true&lt;/em&gt;.
* В это время значение в адресной строке браузера меняется на адрес в P-JAX-ссылке, а в истории посещений добавляется новая строка.
* После получения данных от сервера, P-JAX вырезает указанный участок web-страницы и вставляет туда участок полученный от сервера.&lt;/p&gt;

&lt;p&gt;Такой подход позволяет существенно сократить время загрузки и отрисовки страницы.
Минусом является необходимость обработки дополнительного заголовка на стороне сервера, чтобы определить передавать ли клиенту страницу целиком или только ее участок.&lt;/p&gt;

&lt;h2 id=&quot;play-&quot;&gt;Интеграция в Play-приложение&lt;/h2&gt;

&lt;h3 id=&quot;p-jax--&quot;&gt;Подключаем P-JAX на страницу&lt;/h3&gt;

&lt;p&gt;Для подключения надстройки потребуется добавить jQuery и сам P-JAX&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;@controllers.routes.Assets.at(&quot;javascripts/jquery.pjax.js&quot;)&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Далее необходимо настроить P-JAX, для этого добавим скрипт:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
$(document).pjax(&quot;a[data-pjax=&quot;true&quot;]&quot;, &quot;#pjax-container&quot;, {timeout: 5000, push: true});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Теперь все ссылки с атрибутом &lt;em&gt;data-pjax=”true”&lt;/em&gt; будут перезагружать содержимое элемента с id &lt;em&gt;pjax-container&lt;/em&gt;.
Теперь необходимо позаботиться о формах. Для этого добавим следующее:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).on(&quot;submit&quot;, &quot;form&quot;, function(event) {
    $.pjax.submit(event, &quot;#pjax-container&quot;, {timeout: 5000, push: true})
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;p-jax---1&quot;&gt;Обрабатываем P-JAX на сервере&lt;/h3&gt;

&lt;p&gt;На сервере необходимо разобрать запрос и получить значение заголовка &lt;em&gt;X-PJAX&lt;/em&gt; и, в зависимости от него, отправить HTML-представление целиком или частично.
Для этого можно использовать следующий метод&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;object PjaxController extends Controller {

  protected val pjaxHeader = &quot;X-PJAX&quot;
  protected val defaultValue = &quot;false&quot;
  protected val pjaxUrlHeader = &quot;X-PJAX-URL&quot;

  def status : EssentialAction = Action {
    implicit request =&amp;gt;
      val renderFullView = request.headers.toSimpleMap.getOrElse(pjaxHeader, defaultValue).toBoolean
      Ok(view(renderFullView))
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В файл с базовым шаблоном (&lt;em&gt;layout&lt;/em&gt;) необходимо поместить код управления отрисовкой статической части:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@(renderFullView: Boolean)(content: Html)(implicit request: RequestHeader)

@if(renderFullView) {
  &amp;lt;!DOCTYPE html&amp;gt;
  &amp;lt;!-- full page --&amp;gt;
  @content
}else{
  &amp;lt;!-- part of view --&amp;gt;
  @content
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Из представления необходимо передать параметр отрисовки в базовый шаблон.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@(renderFullView: Boolean)

@views.html.layout(renderFullView) {
  &amp;lt;!-- View content will be here.--&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;Подводные камни&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Redirects&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;По умолчанию P-JAX не будет менять адрес в адресной строке при перенаправлении. Для изменения значения необходимо явно указать какой URL необходимо вставить в адресную строку.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pjax_s = request.headers.toSimpleMap.getOrElse(pjaxHeader, defaultValue)
Redirect(call).withHeaders((pjaxHeader, pjax_s), (pjaxUrlHeader, request.uri))
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Подтверждение оперции&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если Вы хотите сделать диалог подтверждения, например при удалении элемента, необходимо воспользоваться событием &lt;em&gt;pjax:beforeSend&lt;/em&gt; и перехватить событие отправки запроса:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(document).on(&quot;pjax:beforeSend&quot;, function(e) {
        link = $(e.relatedTarget)
        e.preventDefault()
        e.stopImmediatePropagation()
        // do something useful
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;JavaScript&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;При работе с JavaScript и P-JAX необходимо помнить, что фактически страница, с которой мы работаем одна. Весь JavaScript, единожды загруженный, будет храниться в памяти и выполняться.
При этом могут возникать ошибки, связанные с повторной загрузкой скриптов или повторной привязкой событий, например &lt;em&gt;onClick&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Также необходимо помнить о дублировании кода инициализации событий при загрузке страницы и при срабатывании &lt;em&gt;pjax:complete&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Работа с формами&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;При возврате ошибок в заполнении формы от сервера клиенту использование HTT-кодов ответов, отличных от 200-ой серии, опасно. По умолчанию такие ответы будут попадать в &lt;em&gt;error&lt;/em&gt;-callback методов P-JAX и не будут приводить к перерисовке области.
Решением может служить использование &lt;em&gt;OK&lt;/em&gt; вместо &lt;em&gt;BadRequest&lt;/em&gt; (хотя в примерах PlayFramework используется второе).&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;Выводы&lt;/h3&gt;

&lt;p&gt;Хотя P-JAX не очень распространен в сети, его использование позволяет существенно ускорить загрузку страниц Вашего web-приложения и тем самым улучшить UX.
Для сравнения у нас загрузка страницы без P-JAX занимает 600-2500 мс, с P-JAX 100-300мс.
Также плюсом можно считать неизменность привычного workflow при работе с web-страницами: мы также собираем html на сервере и не задействуем большое количество JavaScript на клиенте.&lt;/p&gt;

&lt;p&gt;Можно отметить следующие минусы:
* увеличение количества кода и возможности ошибиться при обработке заголовков и в коде инициализации на клиенте
* меньшая производительность относительно single-page клиентских фремворков (Angular, Ember, Backbone…)
* меньшая или отсутствующая структуризация клиентского кода относительно single-page клиентских фремворков (Angular, Ember, Backbone…)&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;Ссылки&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/defunkt/jquery-pjax&quot;&gt;P-JAX плагин&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://pjax.heroku.com&quot;&gt;Приложение-пример P-JAX&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/pvillega/pjax-Forms&quot;&gt;Пример использования PJAX и Play&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>/code%20quality/2014/06/17/play-with-pjax</link>
                <guid>/code%20quality/2014/06/17/play-with-pjax</guid>
                <pubDate>2014-06-17T00:00:00+04:00</pubDate>
        </item>

        <item>
                <title>Code quality tools in Scala projects</title>
                <description>
&lt;h2 id=&quot;scala&quot;&gt;Инструменты улучшения качества кода в проектах на Scala&lt;/h2&gt;

&lt;p&gt;Мы занимаемся разработкой на Scala уже порядка года и за это время накопили некоторый инструментарий, чтобы следить за качеством кода, который мы пишем.
В этой статье я постараюсь описать эти инструменты и как мы их используем.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;Инструменты&lt;/h3&gt;

&lt;p&gt;На данный момет мы используем 3 инструмента:
1. Linter - производит статический анализатор кода;
2. ScalaStyle - производит анализ исходных кодов на предмет соответствия стандарту и прнципам написания кода;
3. JaCoCo - производит оценку покрытия кода тестами.&lt;/p&gt;

&lt;p&gt;Ссылки на инструменты приведены в &lt;a href=&quot;#links&quot;&gt;последнем разделе поста&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;linter&quot;&gt;Linter&lt;/h3&gt;

&lt;p&gt;linter был первым инструментом, который мы включили в проекты.
Да, сообщения scalac и sbt гораздо более информативны и полезны, чем сообщения javac и maven, однако они не позволяют отследить некоторые неприятные моменты в коде.
linter же позволяет отследить участки кода, возможно содержащие ошибки - например места в коде с использованием небезопасных сравнений.&lt;/p&gt;

&lt;p&gt;В итоге уже в первую неделю использования linter позволил вычистить большую часть базу кода от подобных опасных выражений и иcправить некоторые замаскированные баги.&lt;/p&gt;

&lt;h3 id=&quot;scalastyle&quot;&gt;ScalaStyle&lt;/h3&gt;

&lt;p&gt;ScalaStyle помогает нам следовать стандарту и рекомендациям написания кода на Scala. Это оптимизированный для Scala наследник CodeStyle, разработанного для Java.
После превой проверки кода мы получили огромное количество предупреждений - как безобидных, вроде превышения длины строки кода, так и более неприятных, например магических чисел в коде.
Отчасти в подобных результатах проверки виновата официальная документация PlayFramework, например &lt;a href=&quot;http://www.playframework.com/documentation/2.3.x/ScalaActions&quot;&gt;здесь&lt;/a&gt; не указываются возвращаемые типы для публичных методов.
Но всетаки большую часть ошибок в оформлении кода допустили мы сами.&lt;/p&gt;

&lt;p&gt;Теперь мы более внимательно следим за тем, как мы пишем, и ScalaStyle нам в этом помогает.&lt;/p&gt;

&lt;h3 id=&quot;jacoco&quot;&gt;JaCoCo&lt;/h3&gt;

&lt;p&gt;В сети доступно несколько вариантов со своими приемуществами и недостатками (например &lt;a href=&quot;http://mtkopone.github.io/scct/&quot;&gt;scct&lt;/a&gt;, &lt;a href=&quot;http://scoverage.org/&quot;&gt;scoverage&lt;/a&gt; ).
Мы остановились на JaCoCo по причине наличия плагина для Jenkins и удобной конфигурации.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;Все в сборе&lt;/h3&gt;

&lt;p&gt;Чтобы можно было в любой момент получить отчет о результатах проверок кода проектов, мы внедрили процесс проверки в сборку проектов.
В качестве инструмента &lt;a href=&quot;http://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D0%BF%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%BD%D0%B0%D1%8F_%D0%B8%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F&quot;&gt;CI&lt;/a&gt; мы используем &lt;a href=&quot;&quot;&gt;Jenkins&lt;/a&gt;
После заливки изменнений в коде в центральный репозиторий Jenkins запускает тесты и отдельно запускает проверку стилистики кода, после чего производится сбор статистики и формирование графиков и таблиц.&lt;/p&gt;

&lt;p&gt;Статический анализ мы проводим при каждой сборке, как на сервере Jenkins, так и локально на разработческих машинах. Время компиляции увеличивается несущественно, а разработчик сразу получает полезную информацию.
Кроме того разработчик не забывает провести проверку перед отправкой кода в центральный репозиторий, например.&lt;/p&gt;

&lt;h3 id=&quot;a-namelinksa&quot;&gt;Полезные ссылки&lt;a name=&quot;links&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/HairyFotr/linter&quot;&gt;Linter&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.scalastyle.org/&quot;&gt;ScalaStyle&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.eclemma.org/jacoco/&quot;&gt;JaCoCo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/sbt/jacoco4sbt&quot;&gt;JaCoCo sbt plugin&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Checkstyle+Plugin&quot;&gt;Jenkins Checkstyle plugin&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/JaCoCo+Plugin&quot;&gt;Jenkins JaCoCo plugin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>/code%20quality/2014/05/16/code-quality-tools-in-scala-projects</link>
                <guid>/code%20quality/2014/05/16/code-quality-tools-in-scala-projects</guid>
                <pubDate>2014-05-16T00:00:00+04:00</pubDate>
        </item>

        <item>
                <title>Leverage browser caching</title>
                <description>
&lt;h3 id=&quot;section&quot;&gt;Увеличиваем время жизни кэша статитики в браузере&lt;/h3&gt;

&lt;p&gt;В качестве первого поста в нашем блоге, небольщой набросок от нашего верстальщика.&lt;/p&gt;

&lt;p&gt;В ходе разработки одной из систем с использованием связки Scala + Play framework 2.2.0, было проведено профилирование web-интерфейса, которое показало, что по умолчанию время жизни кэша статических ресурсов всего один час. Что негативно сказывалось на производительности интерфейса и, что больше всего расстраивало руководителей проекта - на индексах производительности выдаваемых сторонними системами профилирования.&lt;/p&gt;

&lt;p&gt;Как выяснилось, решение данного вопроса было довольно простым - добавление в конфигурацию проекта (application.conf) параметра
&lt;code&gt;assets.defaultCache=&quot;max-age=3600&quot;&lt;/code&gt;, где 3600 - время жизни кэша в секундах (в нашем случае, мы ствили неделю, т.е. 604800)&lt;/p&gt;

&lt;p&gt;В заключение, хочется отметить, что в документации на сайте Play Framework, для данной ситуации приводится параметр: http.cacheControl, что справедливо для Play версии 1. Для фреймворка версии 2 и выше, рекомендуется использовать параметр описанный нами выше.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://play.lighthouseapp.com/projects/82401/tickets/853-httpcachecontrol-property-has-no-effect&quot;&gt;Источник информации&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/play%20framework/2014/03/10/leverage-browser-caching</link>
                <guid>/play%20framework/2014/03/10/leverage-browser-caching</guid>
                <pubDate>2014-03-10T00:00:00+04:00</pubDate>
        </item>


</channel>
</rss>
